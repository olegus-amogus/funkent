local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer
local screenGui = Instance.new("ScreenGui")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local RANGE = 100
local UPDATE_RATE = 0.06
local HIT_FILL_TRANSPARENCY = 0.3
local HIT_OUTLINE_TRANSPARENCY = 0.6
local OTHER_FILL_TRANSPARENCY = 0.6
local OTHER_OUTLINE_TRANSPARENCY = 0.9
local enabled = false
screenGui.Name = "RiseGui"
screenGui.ResetOnSpawn = false
screenGui.Parent = player:WaitForChild("PlayerGui")
local frame = Instance.new("Frame")
frame.Name = "MainFrame"
frame.Size = UDim2.new(0, 120, 0, 220) -- поменял размеры: теперь вертикальная полоса
frame.Position = UDim2.new(0.5, -60, 0.5, -180)
frame.AnchorPoint = Vector2.new(0.5, 0.5)
frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
frame.BackgroundTransparency = 0.05
frame.Parent = screenGui
local uiCorner = Instance.new("UICorner")
uiCorner.CornerRadius = UDim.new(0, 8)
uiCorner.Parent = frame
local function createButton(name, parent)
    local btn = Instance.new("TextButton")
    btn.Name = name
    btn.BackgroundColor3 = Color3.fromRGB(70, 130, 240)
    btn.TextColor3 = Color3.new(1,1,1)
    btn.Font = Enum.Font.SourceSansBold
    btn.TextSize = 18
    btn.Text = name
    btn.Parent = parent
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = btn
    return btn
end
local buttonsHolder = Instance.new("Frame")
buttonsHolder.Name = "ButtonsHolder"
buttonsHolder.Size = UDim2.new(1, -20, 1, -20)
buttonsHolder.Position = UDim2.new(0, 10, 0, 10)
buttonsHolder.BackgroundTransparency = 1
buttonsHolder.Parent = frame
local buttons = {}
for i = 1, 4 do
    buttons[i] = createButton("Button"..i, buttonsHolder)
end
local rows = 4
local spacingY = 10
local function layoutButtons()
    local holderAbsSize = buttonsHolder.AbsoluteSize
    if holderAbsSize.X <= 0 or holderAbsSize.Y <= 0 then return end
    local btnWidth = holderAbsSize.X
    local btnHeight = (holderAbsSize.Y - spacingY * (rows - 1)) / rows
    for i, btn in ipairs(buttons) do
        local row = i - 1
        local y = row * (btnHeight + spacingY)
        btn.Size = UDim2.new(0, math.floor(btnWidth), 0, math.floor(btnHeight))
        btn.Position = UDim2.new(0, 0, 0, math.floor(y))
    end
end
buttonsHolder:GetPropertyChangedSignal("AbsoluteSize"):Connect(layoutButtons)
frame:GetPropertyChangedSignal("AbsoluteSize"):Connect(layoutButtons)
layoutButtons()
local btnActions = {
    function() print("Button1 pressed") end,
    function() print("Button2 pressed") end,
    function() print("Button3 pressed") end,
    function() print("Button4 pressed") 
end,
}
buttons[2].Text = "Enable esp"
btnActions[2] = function()
screenGui.ResetOnSpawn = false
local button = buttons[2]
local function createHighlightForCharacter(character, fillColor, fillTransparency, outlineTransparency)
    if not character then return nil end
    local existing = character:FindFirstChild("AutoTargetHighlight")
    if existing and existing:IsA("Highlight") then
        existing.FillColor = fillColor
        existing.FillTransparency = fillTransparency
        existing.OutlineTransparency = outlineTransparency
        return existing
    end
    local highlight = Instance.new("Highlight")
    highlight.Name = "AutoTargetHighlight"
    highlight.Adornee = character
    highlight.FillColor = fillColor
    highlight.FillTransparency = fillTransparency
    highlight.OutlineTransparency = outlineTransparency
    highlight.Parent = character
    return highlight
end

local function removeHighlightForCharacter(character)
    if not character then return end
    local h = character:FindFirstChild("AutoTargetHighlight")
    if h and h:IsA("Highlight") then
        h:Destroy()
    end
end

local function playerFromPart(part)
    if not part then return nil end
    local model = part:FindFirstAncestorOfClass("Model")
    if not model then return nil end
    local humanoid = model:FindFirstChildOfClass("Humanoid")
    if not humanoid then return nil end
    return Players:GetPlayerFromCharacter(model)
end

local function updateHighlights(targetPlayer)
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character.Parent then
            local char = player.Character
            if player == targetPlayer then
                createHighlightForCharacter(char, Color3.fromRGB(0,255,0), HIT_FILL_TRANSPARENCY, HIT_OUTLINE_TRANSPARENCY)
            else
                createHighlightForCharacter(char, Color3.fromRGB(255,0,0), OTHER_FILL_TRANSPARENCY, OTHER_OUTLINE_TRANSPARENCY)
            end
        end
    end
end

local function clearAllHighlights()
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Character then
            removeHighlightForCharacter(player.Character)
        end
    end
end

local function onCharacterAdded(player, character)
    removeHighlightForCharacter(character)
end

for _, p in ipairs(Players:GetPlayers()) do
    p.CharacterAdded:Connect(function(char) onCharacterAdded(p, char) end)
end
Players.PlayerAdded:Connect(function(p) p.CharacterAdded:Connect(function(char) onCharacterAdded(p, char) end) end)
Players.PlayerRemoving:Connect(function(p) if p.Character then removeHighlightForCharacter(p.Character) end end)

-- Луч из центра экрана и основной цикл

local lastTime = 0
RunService.RenderStepped:Connect(function(dt)
    lastTime = lastTime + dt
    if lastTime < UPDATE_RATE then return end
    lastTime = 0

    if not enabled then return end
    if not Camera then return end

    local viewportSize = Camera.ViewportSize
    local screenPoint = Vector2.new(viewportSize.X/2, viewportSize.Y/2)
    local unitRay = Camera:ScreenPointToRay(screenPoint.X, screenPoint.Y)
    local origin = unitRay.Origin
    local direction = unitRay.Direction * RANGE

    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    if LocalPlayer.Character then
        raycastParams.FilterDescendantsInstances = {LocalPlayer.Character}
    end
    raycastParams.IgnoreWater = true

    local result = workspace:Raycast(origin, direction, raycastParams)

    local targetedPlayer = nil
    if result and result.Instance then
        targetedPlayer = playerFromPart(result.Instance)
        if targetedPlayer == LocalPlayer then
            targetedPlayer = nil
        end
    end

    updateHighlights(targetedPlayer)
end)

local function setEnabled(state)
    enabled = state
    if enabled then
        button.Text = "Disable esp"
    else
        button.Text = "Enable esp"
        clearAllHighlights()
    end
end

setEnabled(not enabled)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.H then
        setEnabled(not enabled)
    end
end)

LocalPlayer.AncestryChanged:Connect(function(_, parent)
    if not parent then
        clearAllHighlights()
    end
end)
end
buttons[1].Text ="rise up"
local url = "https://raw.githubusercontent.com/olegus-amogus/UpDown-Script/refs/heads/main/UpDown%20Script"
btnActions[1] = function() loadstring(game:HttpGet(url))() end

for i, btn in ipairs(buttons) do btn.MouseButton1Click:Connect(btnActions[i])
end
do
    local dragging = false
    local dragStart = Vector2.new()
    local startPos = UDim2.new()
    local lastInput
    local function clampPosition(pos)
        local screenSize = frame.Parent.AbsoluteSize
        local x = pos.X.Offset
        local y = pos.Y.Offset
        local w = frame.AbsoluteSize.X
        local h = frame.AbsoluteSize.Y
        if x < 0 then x = 0 end
        if y < 0 then y = 0 end
        if x + w > screenSize.X then x = screenSize.X - w end
        if y + h > screenSize.Y then y = screenSize.Y - h end
        return UDim2.new(pos.X.Scale, x, pos.Y.Scale, y)
    end frame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = frame.Position
            lastInput = input input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end) 

-- Убрано ограничение по перемещению: просто возвращаем candidate без clampPosition

frame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = frame.Position
        lastInput = input
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

frame.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        lastInput = input
    end
end)

RunService.RenderStepped:Connect(function()
    if dragging and lastInput then
        local delta = lastInput.Position - dragStart
        local newXOffset = startPos.X.Offset + delta.X
        local newYOffset = startPos.Y.Offset + delta.Y
        local candidate = UDim2.new(startPos.X.Scale, newXOffset, startPos.Y.Scale, newYOffset)

        -- без ограничения
        frame.Position = candidate
    end
end)
end
